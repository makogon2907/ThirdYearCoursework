%!TEX root=../main.tex


\section*{Аннотация}

DSLab - программный фреймворк для имитационного моделирования и тестирования распределенных систем.

В проекте используется дискретно-событийный подход описания моделей и приложений, где события обрабатываются в пользовательских функциях (callback-ах). В рамках проекта предстоит добавить возможность управлять событиями асинхронно.


\section{Описание проекта и постановка задачи}

\subsection{Устройство DSLab}

В силу широты охвата областей применения фреймворка он организован в виде набора слабо связанных программных модулей, использование которых будет осуществляться через их API. Это даст возможность пользователям фреймворка (исследователям, разработчикам, преподавателям) гибким образом собирать из модулей решения под свои цели, например симуляторы для конкретных типов систем или постановок задач.

Входящие в состав фреймворка модули можно условно разделить на три типа:
\begin{enumerate}
    \item 
    Базовые, функциональность которых используется остальными модулями (например, 
    
    реализация дискретно-событийного моделирования)
    \item
    Универсальные, функциональность которых может быть использована в различных предметных областях (например, модели сети);
    \item
    Специализированные, которые заточены под определенную предметную область (например, библиотеки для моделирования облачных инфраструктур, исследования алгоритмов планирования заданий на кластерах или тестирования решений учебных заданий).
\end{enumerate}

Архитектуру DSLab можно схематично представить в виде трех слоев (Рис. \ref{dslab_arc}), включающих модули соответствующего типа. На рисунке также указаны текущие модули и зависимости между ними. Зависимости от dslab-core (от него зависят все имеющиеся универсальные и специализированные модули) не указаны, чтобы не загромождать рисунок. Таким образом, модули могут зависеть от модулей с нижних слоев, но не наоборот.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.7\linewidth]{images/dslab_arc.png}
    \caption{Архитектура DSLab}
    \label{dslab_arc}
\end{figure}

Описание архитектуры основано на документации проекта \cite{dslab-architecture}. Более подробно про проект можно прочитать в его описании \cite{dslab-description}, его требования \cite{dslab-requirements} и сравнение с аналогами \cite{dslab-analog-cmp}.

Таким образом пользователь при разработке собственной симуляции может либо использовать уже готовые разработанные компоненты, либо реализовывать свои и произвольно их связывать. 


Основным процессом создания симуляции является создание событий и написание процессов реагирования на них. Каждое событие представляет из себя следующую структуру: 
\begin{enumerate}
    \item идентификатор события 
    \item идентификатор компонента, создавшего событие 
    \item идентификатор компонента, которому это событие предназначено доставить 
    \item внутреннее время, когда событие должно наступить
    \item произвольные данные события (<<полезная нагрузка>>)
\end{enumerate}

Таким образом в процессе симуляции разные компоненты генерируют события друг для друга и с помощью низкоуровневого модуля dslab-core обмениваются ими. Чтобы как-то реагировать на событие, каждый компонент реализует единственный обобщенный метод в который dslab-core передает нужное событие. При обработке события компоненты генерируют новые и таким образом цикл симуляции замыкается. 

Получается, что сейчас реагировать на пришедшие события можно только в одном месте -- в той самой функции-callback которую позовет dslab-core. В случае, когда событий немного -- это лаконично выглядит и этим удобно пользоваться. Но в более сложных алгоритмах с большим количеством различных событий, и, что важнее, цепочками событий, на которые нужно последовательно реагировать, подобная модель становится не самой удобной. С такой единой точной входа многие последовательные логичные действия оказываются фрагментированы (разбросаны по разным участкам кода). 

Хотелось бы иметь альтернативную возможность писать на языке программирования более понятный с первого взгляда алгоритм.

Как раз такой возможностью является написание асинхронного кода. Тогда различные сложные куски логики можно было бы выносить в отдельные функции, держать их вместе, просто исполнение бы прерывалось в ожидании какого-то события, чтобы продолжить.

\subsection{Цель}

Добавить возможность пользователю использовать асинхронность при программировании симуляции в DSLab.

\newpage

\section{Актуальность и значимость}

\subsection{Преимущества подхода}

Как уже было описано в мотивации постановки цели этой работы, главное преимущество асинхронной модели~--~удобство при написании сложных многоступенчатых алгоритмов.

Это повысит читаемость кода. Процесс принятия решение о сохранении файла в распределенном хранилище в такой парадигме мог бы выглядеть таким образом (псевдокод):

\begin{figure}[H]
\begin{lstlisting}[language=Python]
    async fn add_file_to_storage(some_file) {
        send_file_to_all_replicas(some_file);
        result = wait_for_confirmation_from_all().await;
        if result.has_quorum {
            send_commit_to_all_replicas();
            wait_for_commit_confirmation_from_quorum().await;
            send_ok_message_to_user();
        } else {
            send_reject_message_to_user();
        }
    }
\end{lstlisting}
\caption{Псевдокод асинхронного взаимодействия нод в симуляции}
\label{pseudocode}
\end{figure}

Посмотрев на функцию можно понять, что она делает, потому что логика последовательна и удобна разбита на подфункции. У нас есть возможность написать такой алгоритм на верхнем уровне, а не обрабатывать сообщения всех типов от всех реплик в единой точке входа.

\subsection{Возможные недостатки подхода}

Программировать в парадигме асинхронного взаимодействия требует соответствующей подготовке пользователя. Не смотря на то, что в любой момент времени исполняется только одна функция, и проблем многопоточного программирования вида \texttt{data-race} не возникает, нужно постоянно держать в голове, что <<параллельно>> могут быть запущены другие процессы, которые могли поменять общую память в то время, когда функция была неактивна. 

\section{Существующие работы и решения}

Подобный подход уже был реализован в других симуляторах, например в \href{https://github.com/osukhoroslov/dslab/blob/main/examples-other/simgrid/ping-pong/process.cpp}
{SimGrid}, но этот код сложно назвать легко читаемым. 

\section{Предлагаемые подходы и методы} 

\subsection{Изучение технологий}
В качестве знакомства с языком программирования Rust и его концепциями я прошел часть курса ШАД по расту \cite{shad-rust}. В нем особенно интересовала глава про асинхронное программирование. У Rust есть официальная документация по асинхронности.\cite{async-book}. Она еще не завершена, но основные идеи по написанию собственного рантайма там изложены.


\subsection{Написание прототипа}
Чтобы дать возможность пользователю писать асинхронный код, нужно создать саму возможность обрабатывать события асинхронно. Для этого нужно написать свой executor задач в DSLab, который будет исходя из внутренней логики (наступление времени, когда событие нужно доставить получателю) понимать, когда и какую асинхронную задачу нужно разбудить, и дать ей продолжить исполнение. 

Для этого нужно реализовать альтернативу dslab-core (или дополнить уже сущетсвующую реализацию), и затем уже пользоваться новым интерфейсом на более верхних уровнях. К счастью, язык Rust дает возможность пользователям самим управлять процессом рантайма: с помощью библиотеки futures \cite{rust-futures} такое поведение может быть реализовано (что на простом примере и описано в официальной документации \cite{async-book}).

Изучив предлагаемые там примеры и посмотрев материалы был реализован прототип \cite{my-demo}. Он поддерживает простой обмен сообщениями и ожидания прихода сообщений от других компьютеров в симуляции. Синтаксис, которым там можно оперировать, соответствует представленному превдокоду (Рис. \ref{pseudocode}). В качестве тестирования прототипа был написан пример реплицированного хранения данных на 3 нодах и процесс обмена разными типами сообщений между ними, чтобы поддерживать консистентное состояние \cite{my-demo-replicas}. 

В примере можно видеть, что управление симуляцией (постановка условий и задач для хранилища) так же осуществляется с помощью асинхронных функций. В этом тоже есть удобство: процесс симуляции пишется как сценарий, который легко читать. 

\subsection{Перенос прототипа в проект DSLab}

Основываясь на полученных результатах в процессе разработки прототипа, нужно встроить эту логику в DSLab. Для этого нужно перевести прототип на использование сущностей из DSLab-а, а также перенести пример использования нового асинхронного ядра. По возможности хочется добиться совместимости уже написанных компонент с новым ядром, тем самым давая пользователю выбор между асинхронной моделью программирования и программирования на callback-ах. Этот вопрос предстоит исследовать. 

\section{Ожидаемые результаты}

\begin{enumerate}
    \item 
    Основным результатом проекта будет возможность для пользователя писать собственные модули и симуляции, используя асинхронную модель. 
    \item В проект добавлены примеры кода, документация по использованию асинхронного ядра.
\end{enumerate}
    
\section{План работ}

Стратегия разработки совпадает со стандартным процессом создания программного продукта 

\begin{table}[!h]
	\centering
\begin{tabular}{|l|p{25em}|c|}
	\hline
№	& Описание этапа &  Примерный срок выполнения \\
	\hline
	1 & Работа с источниками, изучение Rust &  01.11.2022 --- 31.01.2023\\ 
	\hline
2 & Реализация прототипа асинхронного ядра и примеров его использования & 01.12.2022 --- 31.01.2023 \\
	\hline
3	& Перенос прототипа асинхронного ядра в DSLab, написание примеров &  01.02.2023 --- 30.03.2023 \\
\hline
4	& Исследование возможностей совмещения двух парадигм разработки внутри одного модуля &  01.03.2023 --- 30.03.2023 \\
	\hline
5	& Тестирование всех функций и написание документации &  01.04.2022 --- 30.04.2023  \\
	\hline
6	& Написание документации, отчетных документов и подготовка к защите & 01.05.2023 -- 15.05.2023 \\
	\hline
\end{tabular}
	\caption{Ожидаемые сроки выполнения}
	\label{table1}
\end{table}
